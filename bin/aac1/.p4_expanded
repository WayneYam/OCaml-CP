[@@@ocaml.ppx.context
  {
    tool_name = "ppx_driver";
    include_dirs = [];
    load_path = [];
    open_modules = [];
    for_package = None;
    debug = false;
    use_threads = false;
    use_vmthreads = false;
    recursive_types = false;
    principal = false;
    transparent_modules = false;
    unboxed_types = false;
    unsafe_string = false;
    cookies = []
  }]
let () =
  Ppx_module_timer_runtime.record_start Ppx_module_timer_runtime.__MODULE__
open! Base
open! Core
open! Stdio
(** Template starts*)
module Lib = struct
  module Input = struct
    open! Base
    open! Core
    open! Stdio
    
    let read_line () = In_channel.(input_line_exn stdin)
    let read_int () = Int.of_string @@ read_line ()
    
    let read_int_list ?(on = [ ' ' ]) () =
      List.map ~f:Int.of_string @@ String.split_on_chars ~on @@ read_line ()
    ;;
    
    let read_int64 () = Int64.of_string @@ read_line ()
    
    let read_int64_list ?(on = [ ' ' ]) () =
      List.map ~f:Int64.of_string @@ String.split_on_chars ~on @@ read_line ()
    ;;
    
    let to_2ple l =
      match l with
      | [ x; y ] -> x, y
      | _ -> assert false
    ;;
    
    let to_3ple l =
      match l with
      | [ x; y; z ] -> x, y, z
      | _ -> assert false
    ;;
    
    let to_4ple l =
      match l with
      | [ x; y; z; w ] -> x, y, z, w
      | _ -> assert false
    ;;
  end
end
(** Template ends*)
open! Lib.Input
module Pair_int =
  struct
    type t = (int * int)[@@deriving (sexp, compare, hash)]
    include
      struct
        let _ = fun (_ : t) -> ()
        let t_of_sexp =
          (let error_source__007_ = "bin/aac1/p4.ml.Pair_int.t" in
           function
           | Sexplib0.Sexp.List (arg0__002_::arg1__003_::[]) ->
               let res0__004_ = int_of_sexp arg0__002_
               and res1__005_ = int_of_sexp arg1__003_ in
               (res0__004_, res1__005_)
           | sexp__006_ ->
               Sexplib0.Sexp_conv_error.tuple_of_size_n_expected
                 error_source__007_ 2 sexp__006_ : Sexplib0.Sexp.t -> t)
        let _ = t_of_sexp
        let sexp_of_t =
          (fun (arg0__008_, arg1__009_) ->
             let res0__010_ = sexp_of_int arg0__008_
             and res1__011_ = sexp_of_int arg1__009_ in
             Sexplib0.Sexp.List [res0__010_; res1__011_] : t ->
                                                             Sexplib0.Sexp.t)
        let _ = sexp_of_t
        let compare =
          (fun a__012_ ->
             fun b__013_ ->
               let (t__014_, t__015_) = a__012_ in
               let (t__016_, t__017_) = b__013_ in
               match compare_int t__014_ t__016_ with
               | 0 -> compare_int t__015_ t__017_
               | n -> n : t -> ((t)[@merlin.hide ]) -> int)
        let _ = compare
        let (hash_fold_t :
          Ppx_hash_lib.Std.Hash.state -> t -> Ppx_hash_lib.Std.Hash.state) =
          fun hsv ->
            fun arg ->
              let (e0, e1) = arg in
              let hsv = hash_fold_int hsv e0 in
              let hsv = hash_fold_int hsv e1 in hsv
        let _ = hash_fold_t
        let (hash : t -> Ppx_hash_lib.Std.Hash.hash_value) =
          let func arg =
            Ppx_hash_lib.Std.Hash.get_hash_value
              (let hsv = Ppx_hash_lib.Std.Hash.create () in
               hash_fold_t hsv arg) in
          fun x -> func x
        let _ = hash
      end[@@ocaml.doc "@inline"][@@merlin.hide ]
  end
module Pair_set = (Set.Make)(Pair_int)
module Int_set = (Set.Make)(Int)
let get_factor_list range =
  let res = Array.init (range + 1) ~f:(fun id -> ([] : int list)) in
  for i = range downto 1 do
    for j = i + 1 to range / i do res.(i * j) <- (i :: (res.(i * j))) done
  done;
  res
let () =
  let range = 100000 in
  let factor_list = get_factor_list range in
  let (n, q) = to_2ple @@ (read_int_list ()) in
  let array = read_int_list () in
  let queries =
    (List.sort
       ~compare:(fun (a__018_ : (int * int * int * int)) ->
                   fun (((b__019_ : (int * int * int * int)))[@merlin.hide ])
                     ->
                     ((let (t__020_, t__021_, t__022_, t__023_) = a__018_ in
                       let (t__024_, t__025_, t__026_, t__027_) = b__019_ in
                       match compare_int t__020_ t__024_ with
                       | 0 ->
                           (match compare_int t__021_ t__025_ with
                            | 0 ->
                                (match compare_int t__022_ t__026_ with
                                 | 0 -> compare_int t__023_ t__027_
                                 | n -> n)
                            | n -> n)
                       | n -> n)
                     [@merlin.hide ])))
      @@
      (List.init q
         ~f:(fun id ->
               let (l, r, x) = to_3ple @@ (read_int_list ()) in
               (l, r, x, ((q - 1) - id)))) in
  let next_occurence = Array.init (range + 1) ~f:(fun x -> None) in
  let answer = Array.init q ~f:(fun x -> false) in
  let rec calc_answer lst queries idx =
    match lst with
    | [] -> queries
    | hd::tl ->
        let rest_queries = calc_answer tl queries (idx + 1) in
        (next_occurence.(hd) <- (Some idx);
         (let test x r =
            match next_occurence.(x) with
            | None -> false
            | Some r' -> r' <= r in
          let solve_l x r qid =
            let factors = factor_list.(x) in
            answer.(qid) <-
              (List.exists ~f:(fun t -> (test t r) && (test (x / t) r))
                 factors) in
          let rec calc_l queries =
            match queries with
            | [] -> []
            | (l, r, x, qid)::tl ->
                if l = idx then (solve_l x r qid; calc_l tl) else queries in
          calc_l rest_queries)) in
  ignore (calc_answer array (List.rev queries) 1);
  Array.iter ~f:(fun x -> print_string @@ (if x then "YES\n" else "NO\n"))
    answer
